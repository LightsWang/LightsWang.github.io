(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{606:function(t,_,r){"use strict";r.r(_);var o=r(1),v=Object(o.a)({},(function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"_1、概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、概述"}},[t._v("#")]),t._v(" 1、概述")]),t._v(" "),r("p",[t._v("在 ES6之前 ，对象不是基于类创建的，而是用一种称为 构建函数 的特殊函数来定义对象和它们的特征。")]),t._v(" "),r("p",[t._v("创建对象可以通过以下三种方式：")]),t._v(" "),r("ol",[r("li",[t._v("对象字面量")]),t._v(" "),r("li",[t._v("new Object()")]),t._v(" "),r("li",[t._v("自定义构造函数")])]),t._v(" "),r("h2",{attrs:{id:"_2、构造函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、构造函数"}},[t._v("#")]),t._v(" 2、构造函数")]),t._v(" "),r("p",[t._v("构造函数 是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。\n（1）在 JS 中，使用构造函数时要注意以下两点：\n①构造函数用于创建某一类对象，其 首字母要大写\n②构造函数要 和 new 一起使用 才有意义")]),t._v(" "),r("p",[t._v("（2） new 在执行时会做四件事情：\n① 在内存中创建一个新的空对象。\n② 让 this 指向这个新的对象。\n③ 执行构造函数里面的代码，给这个新对象添加属性和方法。\n④ 返回这个新对象（所以构造函数里面不需要 return）。")]),t._v(" "),r("p",[t._v("（3） JavaScript 的构造函数中可以添加一些成员\n①静态成员：在构造函数本身上添加的成员称为 静态成员 ， 只能由构造函数本身来访问\n②实例成员：在构造函数内部创建的对象上添加的成员称为 实例成员 ， 只能由实例化的对象来访问")]),t._v(" "),r("h2",{attrs:{id:"_3、构造函数的问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、构造函数的问题"}},[t._v("#")]),t._v(" 3、构造函数的问题")]),t._v(" "),r("p",[t._v("构造函数方法很好用，但是 存在浪费内存的问题 。 我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？")]),t._v(" "),r("h2",{attrs:{id:"_4、构造函数原型-prototype"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、构造函数原型-prototype"}},[t._v("#")]),t._v(" 4、构造函数原型 prototype")]),t._v(" "),r("p",[t._v("构造函数通过原型分配的函数是所有对象所 共享的 。\nJavaScript 规定， 每一个构造函数都有一个 prototype 属性 ，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。\n我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。")]),t._v(" "),r("ol",[r("li",[t._v("原型是什么 ？\n一个对象，也称 prototype 为 原型对象。")]),t._v(" "),r("li",[t._v("原型的作用是什么 ？\n共享方法 。")])]),t._v(" "),r("h2",{attrs:{id:"_5、对象原型-proto"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5、对象原型-proto"}},[t._v("#")]),t._v(" 5、对象原型 "),r("strong",[t._v("proto")])]),t._v(" "),r("p",[t._v("对象都会有一个属性 "),r("strong",[t._v("proto")]),t._v(" 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数prototype 原型对象的属性和方法，就是因为对象有 "),r("strong",[t._v("proto")]),t._v(" 原型的存在。")]),t._v(" "),r("p",[t._v("① __proto__对象原型和原型对象 prototype 是等价的\n② __proto__对象原型的意义就在于为对象的查找机制提供一个方向 ，或者说一条路线，但是它是一个非标准属性， 因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype")]),t._v(" "),r("h2",{attrs:{id:"_6、constructor-构造函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6、constructor-构造函数"}},[t._v("#")]),t._v(" 6、constructor 构造函数")]),t._v(" "),r("p",[t._v("对象原型（ "),r("strong",[t._v("proto")]),t._v("） 和 构造函数（prototype）原型对象 里面都有一个属性 constructor 属性 ，constructor 我们称\n为构造函数，因为它指回构造函数本身")]),t._v(" "),r("p",[t._v("constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。")]),t._v(" "),r("p",[t._v("一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。")]),t._v(" "),r("h2",{attrs:{id:"_7-原型链"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-原型链"}},[t._v("#")]),t._v(" 7.原型链")]),t._v(" "),r("p",[r("img",{attrs:{src:"/img/web/prototype/yuanxinglian.png",alt:"原型链"}})]),t._v(" "),r("h2",{attrs:{id:"_8-javascript-的成员查找机制-规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-javascript-的成员查找机制-规则"}},[t._v("#")]),t._v(" 8.JavaScript 的成员查找机制(规则)")]),t._v(" "),r("p",[t._v("① 当访问一个对象的属性（包括方法）时，首先查找这个 对象自身 有没有该属性。\n② 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象 ）。\n③ 如果还没有就查找原型对象的原型（ Object的原型对象 ）。\n④ 依此类推一直找到 Object 为止（ null ）。\n⑤ __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。")]),t._v(" "),r("h2",{attrs:{id:"_9-原型对象this指向"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-原型对象this指向"}},[t._v("#")]),t._v(" 9.原型对象this指向")]),t._v(" "),r("p",[t._v("构造函数中的this 指向实例对象.\n原型对象 里面放的是方法, 这个方法 里面的this 指向 的是 这个方法的调用者, 也就是这个 实例对象 .")]),t._v(" "),r("h2",{attrs:{id:"_10-扩展内置对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-扩展内置对象"}},[t._v("#")]),t._v(" 10.扩展内置对象")]),t._v(" "),r("p",[t._v("可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。\n注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。")]),t._v(" "),r("p",[t._v("看到这里，还有疑惑，建议参考这篇优秀的博文，更加深刻理解constructor、"),r("strong",[t._v("proto")]),t._v("、prototype")]),t._v(" "),r("p",[t._v("https://blog.csdn.net/cc18868876837/article/details/81211729")]),t._v(" "),r("p",[t._v("此处引用一下博主的 总结：")]),t._v(" "),r("ul",[r("li",[t._v("我们需要牢记两点：\n①__proto__和constructor属性是对象所独有的；\n② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。")]),t._v(" "),r("li",[t._v("__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。")]),t._v(" "),r("li",[t._v("prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1."),r("strong",[t._v("proto")]),t._v(" === Foo.prototype。")]),t._v(" "),r("li",[t._v("constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。")])])])}),[],!1,null,null,null);_.default=v.exports}}]);